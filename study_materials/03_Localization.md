<!-- omit from toc --> 
# Картографирование и локализация роботов

- [Всё начинается с лидара](#всё-начинается-с-лидара)
- [Попытка отобразить исходную информацию из лидара - не пытка](#попытка-отобразить-исходную-информацию-из-лидара---не-пытка)
- [TF 101](#tf-101)
- [TF - всё относительно](#tf---всё-относительно)
- [Бооольше инструментов](#бооольше-инструментов)
  - [rqt\_tf\_tree](#rqt_tf_tree)
  - [tf\_echo](#tf_echo)
- [TF из Gazebo](#tf-из-gazebo)
- [Настройка Rviz](#настройка-rviz)
- [Задание](#задание)
- [Едем дальше?](#едем-дальше)
- [Поехали!](#поехали)
- [Карта - это матрица](#карта---это-матрица)
- [Цветастая карта](#цветастая-карта)
- [Больше удобства - конфиги](#больше-удобства---конфиги)

## Всё начинается с лидара

Мы с тобой уже научились запускать симулятор и организовывать запуск необходимых узлов и других launch как нам надо.

А ещё и аргументы добавлять, чтобы делать удобное управление запуском!

Это уже хорошие навыки, но давай теперь начнём осваивать каждую часть набора программ (узлов), которые позволяют роботу двигаться к цели, учитывая препятствия!

Начнём мы с лидара.

## Попытка отобразить исходную информацию из лидара - не пытка

Давай запустим наш launch, который стартует симулятор:

```bash
roslaunch turtlebot3_gazebo turtlebot3_world.launch
```

В симуляторе мы уже видели, что лидар у нас на вафле стоит:

<p align="center">
<img src=../assets/lesson_03/01_waffle_lidar.png width=300/>
</p>

Этот лидар выдаёт информацию в виде точек - расстояний до препятствий вокруг на плоскости сканирования. Как же нам её увидеть в сыром виде?

Для этого нам, как обычно, поможет узел, который отображает информацию из робота (как робот видит окружение и какая в нём есть информация) - Rviz.

```bash
rviz
# или rosrun rviz rviz
```

Запускаем её и уже видим странную проблему:

<p align="center">
<img src=../assets/lesson_03/01_04_rviz_issue.png width=300/>
</p>

Как мы тогда до этого работали с Rviz? Всё же было хорошо. Странно очень, но давай попробуем добавить информацию от лидара для отображения: `Add` -> `By topic` -> `/scan` -> `LaserScan`.

<p align="center">
<img src=../assets/lesson_03/01_04_scan_issue.png width=300/>
</p>

Ещё какая-то проблема! Ну всё, дальше двигаться нельзя - ничего не показывается и есть ошибки.

Но давай посмотрим на первую ошибку, в "Global Status" ошибка "Unknown frame map". Это, обычно, происходит, если в "Global Options" -> "Fixed Frame" выбран несуществующий **фрейм**.

Что такое **фрейм** - чуть позже разберём, а пока выбери в Fixed Frame, например, `base_footprint`.

О, в "Global Status" теперь "OK"! Это уже результат! Но в LaserScan новая проблема:

<p align="center">
<img src=../assets/lesson_03/01_04_scan_new_issue.png width=300/>
</p>

Таакс, ну тут уже без новых знаний не обойдёмся...

Ну, поехали, узнаем, про какие *фреймы* идёт речь и почему они так нужны для Rviz!

## TF 101

TF - это очень удобная система в ROS, которая позволяет работать с системами координат (СК) в пространстве. Принято считать, что TF - это сокращение от "transform". То есть, эта система организует трансформацию между СК.

Например, в руке есть плечо, локоть и кисть, у каждой части есть своё положение в пространстве. Мы знаем, что расстояние от плеча до локтя не меняется, как и расстояние от локтя до кисти. Получается, у нас есть СК в плече, локте и кисти. Между плечом и локтём 30 см и между кистью и локтём 30 см. Вот так мы описали относительное положение между СК!

Сначала прямую руку прижмём к туловищу, рука идёт вниз. Допустим, ось Z идет наверх, X - прямо, Y - влево. Если у плеча `X=0, Y=0, Z=0`, то у локтя будет порядка -0.3 м по Z, а у кисти около -0.6 м. Всё остальное по нулям (`X=0, Y=0`).

Теперь поднимем прямую руку ровно наверх, Z локтя и кисти будут иметь те же значения, но положительные. Тут всё просто, так?

А теперь фокус, плечо сгибаем около 65 градусов, локоть на 35 градусов, какие координаты будут у локтя и кисти?

Если ты очень хорошо помнишь тригонометрию и принципы поворотов систем координат, то тебе не составит труда посчитать.

Дать время подумать? =)

Эта математика расчёта уже давно реализована и как раз TF позволяет нам не беспокоиться о том, что и как надо делать в плане расчётов!

Мы описываем отношения между системами координат (СК) и после этого, построив цепочку из СК, можем относительно одной получать информацию об остальных!

Это очень удобно! Но к чему слова? Нам же надо разобраться с проблемой отображения данных в Rviz, что он хочет?

Во-первых, термин **фрейм** в Rviz - это просто система координат. Тут всё просто.

Во-вторых, что за фрейм `base_scan` он хочет? Тут сложнее, но интереснее!

Лидар выдает нам 360 точек (по точке на каждый градус окружности вокруг) - это просто расстояния от лидара до препятствия, числа.

Но чтобы их отобразить, Rviz надо знать, относительно чего рисовать. Ведь лидар где-то на нашем роботе располагается, а значит надо сообщить rviz, где находится лидар на роботе, чтобы относительно этой точки нарисовать точки препятствий вокруг.

Для этого мы сообщим системе, как располагается `base_link` относительно `base_footprint`. `base_footprint` в данном случае выступает центром робота, спроецированном на пол (высота = 0).

Чтобы сообщить о том, насколько высоко располагается лидар относительно пола, добавим запуск узла, который создаёт **статический TF** между фреймами. Создадим новый launch c названием `turtlebot3_tf.launch`:

```xml
<node pkg="tf" type="static_transform_publisher" name="base_footprint_2_base_link" args="0 0 0.3 0 0 0 base_footprint base_scan 100" />
```

> Не забудь, что `<launch>` тэг должен обрамлять весь файл, то есть добавлять надо внутрь него!

Тут мы немного цепляем запуск узлов в launch-файла. Чтобы опубликовать статический TF (сообщить расположение `base_scan` относительно `base_footprint`), нам нужно запустить узел [static_transform_publisher](http://wiki.ros.org/tf#static_transform_publisher) из пакета [tf](https://wiki.ros.org/tf).

Чтобы это сделать мы прописываем в атрибутах тэга `<node>`:

- `pkg` - название пакета, из которого запускаем,
- `type` - название узла, который в пакете надо запустить,
- `name` - как узел будет называться в системе,
- `args` - аргументы узла.

Аргументы у static_transform_publisher узла следующие `x y z yaw pitch roll frame_id child_frame_id period_in_ms`. Разберём:

- `x, y, z` - линейное расположение `child_frame_id` относительно `frame_id`,
- `yaw pitch roll` - угловое расположение (поворот) `child_frame_id` относительно `frame_id`,
- `frame_id child_frame_id` - имена фрейма, между которыми создаём TF,
- `period_in_ms` - частота публикации, обычно ставится 100 или 1000, и норм.

Такс, ну мы много тут всего написали, но главное, что нам теперь надо запустить новый launch и посмотреть, помогло ли это отобразить данные из лидара:

```bash
roslaunch kitty_package turtlebot3_tf.launch
```

Посмотрим Rviz и увидим, что данные отобразились! Отлично!

<p align="center">
<img src=../assets/lesson_03/01_04_rviz_scan_success.png width=400/>
</p>

> Для лучшего отображения точек в LaserScan->"Size (m)" можно поменять размер на 0.03, например

Мы смогли починить недостающую информацию для отображения данных с лидара! В системе не хватало информации о том, как расположен `base_scan` фрейм относительно `base_footprint`!

> :muscle: Попробуй поменять значения `x, y, z, yaw pitch roll` в аргументах TF узла и перезапускать после изменений launch с этим узлом. Посмотри, как это влияет на отображение.

## TF - всё относительно

Результат есть, круто, но не складывается ли ощущение, что мы просто угадали и всё сделали правильно? Ведь, если разбираешься с каким-нибудь инструментом, всегда нужно чётко осознавать, что, как и почему делается!

Во-первых, важно сейчас понять, что СК не существует сама по себе! Именно поэтому мы описываем не расположения фреймов самих по себе, а именно относительное расположение между ними. Так, чтобы отобразить, мы задаём базовый фрейм (Fixed Frame), относительно которого всё и рисуется.

Во-вторых, давай отобразим фреймы в Rviz, чтобы увидеть, как они расположены! `Add` -> `By display type` -> `TF`:

<p align="center">
<img src=../assets/lesson_03/01_04_rviz_tf_frames.png width=500/>
</p> 

Так ведь удобнее, правда?

> :muscle: А теперь попробуй покататься с помощью teleop launch в пакете и скажи, какие из TF (TF - это соотношение между фреймами) являются **статическими**, а каким **динамическими**?

Мы пока не объясняли эти термины, но думаю, тут уже понятно, в чём разница =)

**Статический TF** (`base_footprint` -> `base_scan`) - положение между фреймами не меняются во времени, никогда!
**Динамический TF** (`odom` -> `base_footprint`) - положение между фреймами может меняться во времени.

Почему не бывает динамического фрейма? Всё просто, например, фрейм `base_footprint` относится как к динамическому TF, так и к статическому TF. Нет однозначности в этой характеристике.

Так, прекрасно, мы освоили ещё немного терминов и смогли отрисовать TF в Rviz, чтобы проще было ориентироваться! Отличный результат!

## Бооольше инструментов

Сейчас всё идет по плану, но часто в ходе разработки или отладки системы происходят проблемы и всплывают баги настройки, ой как часто...

Более того, мы смогли отобразить TF в Rviz, но в нём не понятно, как увидеть соотношение между фреймами и более того, численных значений преобразований (TF) между фреймами!

Значит, сейчас пока мы не можем в полной мере понять, что происходит внутри системы - погнали осваивать инструменты!

### rqt_tf_tree

Первый инструмент поможет нам понять, как соотносятся между собой фреймы и кто является источником информации о TF - `rqt_tf_tree`!

Просто стартуем:

```bash
rosrun rqt_tf_tree rqt_tf_tree
```

И вот мы видим простой и приятный интерфейс:

<p align="center">
<img src=../assets/lesson_03/01_04_rqt_tf_tree.png width=500/>
</p>

В этом интерфейсе мы видим, как фреймы зависимы!

> Важно, правильное дерево имеет формат **дерева**, то есть у нижестоящих фреймов не может быть два родителя или стрелочки не могут идти наверх!

> :muscle: Попробуй заменить в `turtlebot3_tf.launch` фрейм `base_footprint` на `base_link` и перезапусти. Отобрази `rqt_tf_tree`, видишь проблему? Ошибка в названии ведёт к созданию двух деревьев, такого тоже быть не должно! Верни обратно, как было =)

С помощью этого инструмента можно понять, как взаимосвязаны фреймы и есть ли ошибки в построении дерева TF, так как на этом достаточно часто происходят ошибки.

### tf_echo

Другой инструмент позволит нам понять численные характеристики той или иной TF - `tf_echo`.

```bash
rosrun tf tf_echo base_footprint base_scan
```

И вот результат:

```
At time 6673.459
- Translation: [0.000, 0.000, 0.300]
- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]
            in RPY (radian) [0.000, -0.000, 0.000]
            in RPY (degree) [0.000, -0.000, 0.000]
At time 6674.462
- Translation: [0.000, 0.000, 0.300]
- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]
            in RPY (radian) [0.000, -0.000, 0.000]
            in RPY (degree) [0.000, -0.000, 0.000]
At time 6675.463
- Translation: [0.000, 0.000, 0.300]
- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]
            in RPY (radian) [0.000, -0.000, 0.000]
            in RPY (degree) [0.000, -0.000, 0.000]
```

Как видно, статическая TF не меняется - логично! =)

> :muscle: Отобрази TF "odom -> base_footprint". Посмотри значения между ними.

> :muscle: Разберись, как в tf_echo задать частоту отображения данных

Отлично! Вот у нас и получилось понять соотношение между фреймами, а также получить информацию о конкретном TF в численном виде, а не "на глаз"!

## TF из Gazebo

Важной хитростью работы с симулятором является то, что модель в симуляторе уже описана с учётом расположения датчиков и деталей между собой. Поэтому, в Gazebo есть узел, который может опубликовать все статические TF, описывающие робота...

Мы не скрывали это от вас, просто важно с некоторыми вещами разобраться поподробнее!

Давай отключим все launch и создадим файл, в который добавим:

- Запуск world.launch
- Запуск публикации информации о расположении частей робота (TF)

    ```xml
    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher">
        <param name="publish_frequency" type="double" value="50.0" />
    </node>
    ```

- Запуск rviz

    ```xml
    <node pkg="rviz" type="rviz" name="rviz" />
    ```

<details>
  <summary>Подсказка</summary>
      
    <launch>
        <include file="$(find kitty_package)/launch/turtlebot3_world.launch" />
        
        <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher">
            <param name="publish_frequency" type="double" value="50.0" />
        </node>

        <node pkg="rviz" type="rviz" name="rviz" />
    </launch>

</details>

А теперь стартуем его!

```bash
roslaunch kitty_package turtlebot3_sim_start.launch
```

Ах да, Rviz же после перезапуска сбивается...

Ну, настрой снова TF, LaserScan и Fixed Frame.

Хм, а фреймвов стало гораздо больше, как же увидеть всё в этой мешанине? Не сложно, просто открой параметры TF и настрой те TF, который хочется видеть (`odom`, `base_footprint`, `base_scan`).

<p align="center">
<img src=../assets/lesson_03/01_04_rviz_tf_setup.png width=500/>
</p>

Отлично, так значит, можно сразу получить описание робота без необходимости прописывать каждый TF руками?

Не совсем, в этом случае расположения фреймов описаны в симуляторе, а значит в нём есть вся необходимая информация!

Если у тебя робот без модели в симуляторе, то придётся описывать ручками, но это не так страшно, как кажется! Берём рулетку и в бой =)

На деле у нас появился launch-файл, который стартует все необходимое в симуляторе, теперь можно идти дальше и изучать другие аспекты работы системы ROS на роботе!

> Но погоди отключать настроенный Rviz!

## Настройка Rviz

Такс, не спешим, у нас осталась одна нерешённая проблемка...

Мы тут перезапустили Rviz и приходится каждый раз настраивать! Это же уйма времени будет потрачена! Не годится.

Давай посмотрим `rviz -h` и найдём ооочень полезную строку:

```bash
-d [ --display-config ] arg A display config file (.rviz) to load
```

То есть, в rviz есть опция, которая позволяет подгрузить конфигурацию отображения из файла? Хм, это может быть полезно!

Закончи настройку отображения информации как тебе хочется (может точки больше сделаешь?) и жмём кнопку `File`->"`Save Config As`" (сверху слева):

<p align="center">
<img src=../assets/lesson_03/01_04_rviz_file_button_pos.png width=300/>
</p>

> Не нажимай "Save Config" или сочетание "Ctrl+S", так как это сохранит нынешнее отображение как настройки по-умолчанию!

В окне сохранения пройди в пакет в папку kitty_vision и там создай папку `rviz` и туда сохрани в файл под названием `sim_initial.rviz`.

А тепееерь, магия, погнали в `turtlebot3_sim_start.launch` и там к запуску Rviz добавь `args="-d $(find kitty_package)/kitty_vision/rviz/sim_initial.rviz"`. Это по сути путь до нашей конфигурации в пакете.

Добавил? Отлично, перезапускай!

Всё на месте! Теперь тебе не придется каждый раз настраивать Rviz! А ещё тут есть приятный сорприз, если поменять что-либо в отображении и нажать "Ctrl+S", то это сохранится и в следующем запуске будет тут же! Шикарно!

А всего-то поняли, что есть проблема и в два счёта решили ее, проверив help!

> ! Практика показывает, что создание rviz конфигураций под каждую задачу является удобным способом хранения. Не пытайтесь держать одну конфигурацию под все задачи, например, "проверка работы модели в симуляторе", "отображение данных с лидара", "отображения инфы от планировщика" и т.д.

## Задание

- Попробуй отобразить другую информацию в Rviz - теперь ты это умеешь! Посмотри, что происходит с остальными фреймами при движении.
- Посмотри дерево TF после перехода на `robot_state_publisher`.
- Посмотри значения TF между разными фреймами, все ли значения понятны?
  
## Едем дальше?

Помните еще на первом занятие мы с вами запускали `launch` в котором подгружалась модель нашего робота в каком-то мире? Пришло время разобраться с тем, что, на самом деле мы запускали.

<p align="center">
    <img src=../assets/lesson_03/turtle_world.png width=600/>
</p>

Итак, поехали! Чтобы посмотреть их начинку воспользуемся утилитой `roscat`! Например, залезем в `turtlebot3_world.launch`:

```bash
roscat turtlebot3_gazebo turtlebot3_world.launch
```

В результате получим:

```xml
<launch>
  <arg name="model" default="$(env TURTLEBOT3_MODEL)" doc="model type [burger, waffle, waffle_pi]"/>
  <arg name="x_pos" default="-2.0"/>
  <arg name="y_pos" default="-0.5"/>
  <arg name="z_pos" default="0.0"/>

  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world"/>
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="gui" value="true"/>
    <arg name="headless" value="false"/>
    <arg name="debug" value="false"/>
  </include>

  <param name="robot_description" command="$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro" />

  <node pkg="gazebo_ros" type="spawn_model" name="spawn_urdf"  args="-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description" />
</launch>
```

Хмм, а тут немало всего, но мы на прошлом уроке уже познакомились с тегами  `arg`, `node` и `param`!

А ещё, мы нашли, почему он всё время требует переменную окружения `TURTLEBOT3_MODEL`! Вот и первый момент, который хочется исправить в этих скриптах, чтобы его не задавать!

Выполните в терминале из папки `home` команду:

```bash
gedit ./.bashrc
```
У вас откроется файл, в котором мы добавляли наше рабочее пространство, в самой последней строчке запишите строчку `export TURTLEBOT3_MODEL="burger"`. Именно это избавит нас от постоянного написания модели робота при запуске `launch` файлов в `turtlebot3`

Кстати, мы вам не рассказали, но роботы у нас тоже бывают разные, в них отличаются названия. Есть: `waffle, burger и waffle pi` - выберите ту, которая вам больше нравится.

<p align="center">
    <img src=../assets/lesson_03/turtle_family.png width=600/>
</p>

Давайте теперь посмотрим, что у нас вообще есть в пакете `turtlebot3_gazebo`, для этого сделаем команду:

```bash
roscd turtlebot3_gazebo
code .
```
Так, мы откроем пакет в `VS Code`, а в папке `launch` можем найти кучу файлов для запуска робота на различных площадках:

<p align="center">
    <img src=../assets/lesson_03/gazebo.png width=200/>
</p>

Наиболее интересным, на наш взгляд является файл `turtlebot3_house.launch`. Давайте скопируем его в наш пакет, для этого создадим папку `world` и поместим его туда, сохраня название. Давайте запустим !

```bash
roslaunch kitty_package turtlebot3_house.launch
```

<p align="center">
    <img src=../assets/lesson_03/house.png width=600/>
</p>

Дальше давайте исследуем пакет `turtlebot3_slam` и посмотрим `turtlebot3_slam.launch`

```xml
<launch>
    <!-- Arguments -->
    <arg name="model" default="$(env TURTLEBOT3_MODEL)" doc="model type [burger, waffle, waffle_pi]"/>
    <arg name="configuration_basename" default="turtlebot3_lds_2d.lua"/>
    <arg name="open_rviz" default="true"/>
    <arg name="set_base_frame" default="base_footprint"/>
    <arg name="set_odom_frame" default="odom"/>
    <arg name="set_map_frame"  default="map"/>
    
    <!-- TurtleBot3 -->
    <include file="$(find turtlebot3_bringup)/launch/turtlebot3_remote.launch">
      <arg name="model" value="$(arg model)" />
    </include>
  
    <node pkg="gmapping" type="slam_gmapping" name="turtlebot3_slam_gmapping" output="screen">
      <param name="base_frame" value="$(arg set_base_frame)"/>
      <param name="odom_frame" value="$(arg set_odom_frame)"/>
      <param name="map_frame"  value="$(arg set_map_frame)"/>
      <rosparam command="load" file="$(find turtlebot3_slam)/config/gmapping_params.yaml" />
    </node>
  
    <!-- rviz -->
  <group if="$(arg open_rviz)">
    <node name="rviz" pkg="rviz" type="rviz"/>
  </group>

  </launch>
```

Давайте скопируем его в наш пакет, для этого в папке `kitty_software` сохраним его. А далее запустим (прошлый наш launch вырубать не надо):

```bash
roslaunch kitty_package turtlebot3_slam.launch
```
<p align="center">
    <img src=../assets/lesson_03/clean_rviz.png width=500/>
</p>

У нас открылся пустой `rviz`, но нам нужно добиться того, чтобы данные корректно стали отображаться. Для этого давайте проведем настройку, чтобы добиться результата, как показано на рисунке ниже:

<p align="center">
    <img src=../assets/lesson_03/rviz_setting.png width=150/>
</p>

В результате мы должны получить следующий результат:

<p align="center">
    <img src=../assets/lesson_03/rviz_house.png width=500/>
</p>

Чтобы постоянно не проводить настройку при каждом запуске `launch` файла, нужно сохранить конфиг. Для этого выполняем следующие действия:

Сохраняем наш конфиг в папку ```rviz``` внутри ```kitty_vision```. Для этого нужно ее заранее создать и выполнить `Ctrl+Shift+s`. Названия желательно делать понятные каждому, поэтому предлагаем оставить такое: `view_slam.rviz`

>🦾	Мы добрались до первого задания. Вы не заметили, что при запуске `Gazebo` у нас начинает подлагивать компьютер? Давайте отключим его отображение, а для этого разберемся с помощью какого аргумента мы можем это отключить в `turtlebot3_house.launch`.

>🦾	Мы говорили, что менять аргументы в исходном файле это не слишком хорошая практика, поэтому давайте в начале `turtlebot3_house.launch` добавим тег `arg` с названием `gazebo`, который будет принимать значения либо `True` или `False`, а само значение перекидывать в найденный вами в прошлом задание аргумент `<include file="$(find gazebo_ros)/launch/empty_world.launch">`

##  Поехали!

На прошлом уроке мы с вами создавали файл, который позволяет управлять нашим роботом с компьютера. Назвали мы его, как `my_joy_launch.launch` или как-то похоже

>🦾 Новое задание. Давайте объедим три файла в один (тот, который запускает симулятор мира робота, построение карты и управление с джойстика) - мы ведь решили уже, что не очень удобно запускать по 20 файлов одновременно. Создадим в `kitty_software` файл `full_turtle_joy_mapping.launch`

Справились? Запускаем!

```bash
roslaunch kitty_package full_turtle_joy_mapping.launch
```

Теперь мы можем кататься по помещению и строить карту - пробуем!

<p align="center">
    <img src=../assets/lesson_03/house_mapping.png width=600/>
</p>

## Карта - это матрица

Если попробовать вывести информацию с топика через `rostopic echo /map`, то можно получить кучу нечитаемого вида. Именно поэтому важно уметь представлять информацию различными способами, так как что-то можно посмотреть в числах, а что-то воспринимается визуально (или в другой интерпретации). Мы ведь не смотрим картинки попиксельно?

Так и здесь, карта - это на самом деле прямоугольная матрица из чисел. Если ты знаешь Python, MATLAB или другой язык, касаемо математики (или саму математику), то ты уже знаешь, что матрица - это двумерный массив с некоторым кол-вом строк и столбцом (высота и ширина карты).

Чтобы получить эти значения касательно карты, можно вывести информацию из топика `/map_metadata`:

```md
resolution: 0.05000000074505806
width: 4000
height: 4000
```

Ширина и высота заданы в точках (элементах матрицы), а `resolution` показывает разрешение - сколько метров покрывает каждый элемент матрицы [метров на блок].

Можно считать, что вся карта - это картинка, каждый элемент матрицы - это пиксель, а физический размер пикселя - это разрешение.

Это важно понимать, так как, например, ширину и высоту можно настраивать под свои нужды, чтобы потреблять меньше оперативной памяти, а разрешение часто влияет на скорость обработки и загрузку процессора.

## Цветастая карта

Отлично, с форматом передачи разобрались, но что значат черные/белые/серые клетки на карте в rviz?

Если посмотреть в [документацию типа топика](http://docs.ros.org/en/api/nav_msgs/html/msg/OccupancyGrid.html) `/map`, то можно увидеть, что в `data` поле хранятся значения "-1" и от 0 до 100. Вот и на карте у нас они отображаются:

<p align="center">
<img src=../assets/lesson_03/01_07_rviz_map_colors.png width=400/>
</p>

В отображении карты от gmapping используется три основных цвета:

- черный (значение 100) - точки в матрице, на которых находится препятствие
- белый (значение 0) - точки, где точно нет препятствия
- серый (значений -1) - неизвестно, так как туда не попадал лазер.

Тут можно сразу задать вопрос, а почему между столбами и в некоторых зонах белого появляются серые точки? В первом случае лидар не достаёт до стены на другой стороне карты, поэтому нельзя точно сказать, есть ли там препятствие. Алгоритм gmapping работает по принципу "скан достал до препятствия, значит на пути от робота до этой точки нет препятствий.

> ! Обрати внимание, что в системе карт ROS есть понятие "неизвестная" местность и она отличается от состояния "свободно". Это будет важно понимать при дальнейшей работе.

## Больше удобства - конфиги

В ходе изучения работы gmapping мы пробовали устанавливать разные параметры, но представь, что тебе надо поменять 10, 20 или больше параметров. Это приводит launch к разрастанию (на каждый параметр своя строка).

А что если в launch ещё и не один узел надо так настраивать?

В таком случае было бы удобно вынести конфигурацию параметров в отдельное место. Этим местом будет "конфигурационный файл". А если проще - конфиг.

Можно сделать файл в формате YAML и удобно в нём настраивать под себя узел, а launch будет заниматься своей работой - запускать узлы!

Давай сделаем свой конфиг в пакете для узла `gmapping`. Создаём папку `config` внутри пакета. Внутри этой папки создаём файл `gmapping_params.yaml` со следующим содержимым:

```yaml
map_update_interval: 2.0
maxUrange: 3.0
sigma: 0.05
kernelSize: 1
lstep: 0.05
astep: 0.05
iterations: 5
lsigma: 0.075
ogain: 3.0
lskip: 0
minimumScore: 50
srr: 0.1
srt: 0.2
str: 0.1
stt: 0.2
linearUpdate: 1.0
angularUpdate: 0.2
temporalUpdate: 0.5
resampleThreshold: 0.5
particles: 100
xmin: -10.0
ymin: -10.0
xmax: 10.0
ymax: 10.0
delta: 0.05
llsamplerange: 0.01
llsamplestep: 0.01
lasamplerange: 0.005
lasamplestep: 0.005
```
> ✅ На первый взгляд может показаться, что параметров очень много, но многие из них нужны только для точной настройки алгоритма. Изменение всех параметров в практике может и не пригодится, но понимание принципа работы алгоритма никогда не бывает лишним. 

Теперь нам нужно поменять путь до конфига в файле `turtlebot3_slam.launch`. Поменяйте и проверьте, что все корректно запускается. Тут для загрузки конфига мы просто используем атрибуты `command` и `file`. Первый указывает, что надо сделать и из всех представленных в доках нам нужна команда `load`. А в `file` как обычно пишем путь до файла конфига.

>🦾 Пользуясь [оффициальной документацией с RosWiki](https://wiki.ros.org/gmapping) по пакету gmapping, найдите параметр который отвечает за разрешение карты. Попробуйте изменить это значение как в меньшую, так и в большую сторону посмотреть как это повлияет на внешний вид карты и работоспособность системы. 
- К каким проблемам может привести недостаточное разрешение карты?
- Как изменилась скорость работы системы при установке слишком малого разрешения (0.001)? Почему это произошло?
